#summary Implementation thoughts on long variable names
#labels hash

= Legal variable name syntax =

The current version takes a variable name for each of the commands :,!,$,@,{ and &. A command can follow immediately so $a-b would be goto variable a, reduce, comment "b". We would like our code to be able to run ebf without change so a variable name should be limited to `/[a-zA-z_]/`. As a test i have created an example using variables from ebf to check if a character is within `/[a-zA-Z_]/`. Have a look at [https://code.google.com/p/ebf-compiler/source/browse/trunk/examples/match_word_or_underscore.ebf match_word_or_underscore.ebf] under examples. I'd like to credit {{{(>>[-<]<[>]@m$v-)}}} which is used to identify more than one character within a range with only one if test to [http://www.hevanet.com/cristofd/brainfuck/intermediate.html Daniel B. Cristofani]

= New flow =

 * We keep the main switch. If the command is one of :,!,$,@,{ or &, store a index which indicates which command and remove call to the implementing macro.
 * After the switch the index is checked. If non-zero a routine to retrieve (from , or buffer) the characters invoving the name of routine. First char is always taken, next char has to be [a-zA-Z_]. 
 * a hash function is applied if there are more than one character
 * if the char last read is not [a-zA-Z_] (except first char), that is put in a location for further use.
 * a last switch checks and arund appropriate macro and macroes are changed to retrieve byte from a predefined location (v) instead of reading.
 * read routine needs to check for left over char first, before checking buffer and stdin.

= Hash function =

The very easy Bernstein hash is a good choice. 
For every new character we multiply the currect accumulator with 33 and add the char to accumulator. Overflow will happen but we don't care :)