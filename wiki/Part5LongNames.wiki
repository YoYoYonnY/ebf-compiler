#summary Implementation thoughts on long variable names
#labels hash,Featured

= Legal variable name syntax =

The current version takes a variable name for each of the commands :,!,$,@,{ and &. A command can follow immediately so $a-b would be goto variable a, reduce, comment "b". We would like our code to be able to run ebf without change so a variable name should be limited to `/[a-zA-z_]/`. As a test i have created an example using variables from ebf to check if a character is within `/[a-zA-Z_]/`. Have a look at [https://code.google.com/p/ebf-compiler/source/browse/trunk/examples/match_word_or_underscore.ebf match_word_or_underscore.ebf] under examples. I'd like to credit {{{(>>[-<]<[>]@m$v-)}}} which is used to identify more than one character within a range with only one if test to [http://www.hevanet.com/cristofd/brainfuck/intermediate.html Daniel B. Cristofani]

= New flow =

 * We keep the main switch. If the command is one of :,!,$,@,{ or &, store a index which indicates which command and remove call to the implementing macro.
 * After the switch the index is checked. If non-zero a routine to retrieve (from , or buffer) the characters invoving the name of routine. First char is always taken, next char has to be [a-zA-Z_]. 
 * a hash function is applied if there are more than one character
 * if the char last read is not [a-zA-Z_] (except first char), that is put in a location for further use.
 * a last switch checks and arund appropriate macro and macroes are changed to retrieve byte from a predefined location (v) instead of reading.
 * read routine needs to check for left over char first, before checking buffer and stdin.
 * macro create should add leftover char to macro.
 * macro expand needs to move leftover char to buffer so that it will be interpreted after the body of the macro.

= Hash function =

At first I though the very easy Bernstein hash ( h = h*33 + new_val ) was a good choice, but that algorithm is good when we have larger cell sizes and arrays. I ended up having to reduce the value to something below 256 and the larger cell size the slower implementation. The actual method used now is h = h*2 + new_val-1 and h is then mod 251-ed and incremented so we have from 1 to 251 as values.